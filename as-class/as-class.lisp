(defpackage :structure-ext.as-class(:use :cl)
  (:import-from :lambda-list #:Vars<=lambda-list)
  (:import-from :resignal-bind #:Resignal-bind)
  (:nicknames "AS-CLASS")
  (:export
    #:defstruct*
    ))
(in-package :structure-ext.as-class)
(named-readtables:in-readtable with-package:syntax)

(defmacro defstruct* (&body body)
  (multiple-value-bind(name options documentation slots)(parse body)
    (check options)
    (multiple-value-bind(slots initargs)(slots slots options name)
      `(PROGN
	 (DEFCLASS,name,(super-classes options)
	   ,slots
	   ,@(may-documentation documentation))
	 ,@(constructors name options initargs)
	 ,@(print-function name options)
	 ,@(copier name options)
	 ,@(predicate name options)
	 ,@(accessors name options)
	 ',name))))

(defun parse(body)
  (labels((NAME&OPTIONS(name&options)
	    (if(symbolp name&options)
	      (values name&options nil)
	      (values (car name&options) (CANONICALIZE(cdr name&options)))))
	  (SLOTS(slots)
	    (if(stringp(car slots))
	      (values (car slots)(CANONICALIZE(cdr slots)))
	      (values nil (CANONICALIZE slots))))
	  (CANONICALIZE(slots)
	    (mapcar #'uiop:ensure-list slots))
	  )
    (multiple-value-call #'values (NAME&OPTIONS(car body))(SLOTS(cdr body)))))

(defun check(options)
  (flet((check(type)
	  (when(assoc type options)
	    (error "Options ~S is invalid in DEFSTRUCT* form.~%~S"type options))))
    (mapc #'check `(:type :named :initial-offset))))

(defun super-classes(options)
  (mapcar #'second (collect-option :include options)))

(defun collect-option(option options)
  (remove-if (complement(lambda(x)(eq option x)))
	     options :key #'car))

(defun slots(slots options class-name)
  (let*((conc-name(conc-name options class-name))
	(includes(uiop:while-collecting(acc)
		   (dolist(include(collect-option :include options))
		     (dolist(slot-option(cddr include))
		       (acc (enslot slot-option conc-name)))))))
    (loop :for slot :in slots
	  :with initargs
	  :collect (multiple-value-bind(slot initarg)(enslot slot conc-name)
		     (push initarg initargs)
		     slot)
	  :into forms
	  :finally (return (values (nconc forms includes)
				   initargs)))))

(defun conc-name(options class-name)
  (let((conc-name(assoc :conc-name options)))
    (if conc-name
      (cadr conc-name)
      (format nil "~A-"class-name))))

(macrolet((!(form)
	    `(RESIGNAL-BIND((ERROR()'SIMPLE-ERROR
			      :FORMAT-CONTROL "Missng initform.~%~S"
			      :FORMAT-ARGUMENTS(LIST SLOT)))
	       ,form)))

  (defun enslot(slot conc-name) ; separated cause of huge.
    (let((null(make-symbol "NULL")))
      (labels((PARSE-SLOT(slot)
		(if(symbolp slot)
		  (values slot null nil)
		  (values (car slot)
			  (cadr slot)
			  (cddr slot))))
	      (MAY-TYPE-SPEC(slot-options)
		(let((spec(!(getf slot-options :type))))
		  (when spec
		    `(:TYPE ,spec))))
	      (INITFORM(init-form)
		`(:initform ,init-form))
	      (INITARG(slot-name)
		(intern(symbol-name slot-name) :keyword))
	      (MAY-ACCESSORS(conc-name slot-name slot-options)
		`(,(if(!(getf slot-options :read-only))
		     :reader
		     :accessor)
		   ,(METHOD-NAME conc-name slot-name)))
	      )
	(multiple-value-bind(slot-name init-form slot-options)(PARSE-SLOT slot)
	  (let((initarg(INITARG slot-name)))
	    (values `(,slot-name
		       ,@(MAY-TYPE-SPEC slot-options)
		       ,@(INITFORM init-form)
		       ,@`(:initarg ,initarg)
		       ,@(MAY-ACCESSORS conc-name slot-name slot-options)))))))))

(defun method-name(conc-name slot-name)
  (intern(format nil "~@[~A~]~A" conc-name slot-name)))

(defun may-documentation(doc)
  (when doc
    `((:DOCUMENTATION ,doc))))

(defun constructors(name options initargs)
  (let((constructors(collect-option :constructor options)))
    (labels((DEFAULT-CONSTRUCTOR(constructor)
	      `(DEFUN,constructor(&REST ARGS)
		  (APPLY #'MAKE-INSTANCE ',name ARGS)))
	    (DEFAULT-NAME(name)
	      (intern(format nil "MAKE-~A"name)))
	    (REC(constructors &optional acc)
	      (if(endp constructors)
		(DO-RETURN acc)
		(BODY(car constructors)(cdr constructors)acc)))
	    (BODY(constructor rest acc)
	      (etypecase constructor
		((CONS T NULL)
		 (REC rest (push (DEFAULT-CONSTRUCTOR(DEFAULT-NAME name))
				 acc)))
		((CONS T (CONS T NULL))
		 (if(second constructor)
		   (REC rest (push (DEFAULT-CONSTRUCTOR(second constructor))
				   acc))
		   (DO-RETURN acc)))
		((CONS T (CONS T (CONS T NULL)))
		 (REC rest
		      (push `(DEFUN,(second constructor),(third constructor)
			       (MAKE-INSTANCE ',name ,@(CANONICALIZE (third constructor)
								     initargs)))
			    acc)))))
	    (CANONICALIZE(lambda-list initargs)
	      (loop :for var :in (Vars<=lambda-list lambda-list)
		    :when (find var initargs :test #'string=)
		    :collect (intern(symbol-name var):keyword)
		    :and :collect var))
	    (DO-RETURN(acc)
	      (let((default(DEFAULT-NAME name)))
		(if(or (find default acc :key #'second)
		       (find nil constructors :key #'second))
		  acc
		  (push (DEFAULT-CONSTRUCTOR default) acc))))
	    )
      (if(null constructors)
	`(,(DEFAULT-CONSTRUCTOR(DEFAULT-NAME name)))
	(REC constructors)))))

(defun print-function(name options)
  (let((print-function(cadr(assoc :print-function options)))
       (print-object(cadr(assoc :print-object options))))
    (when(and print-function print-object)
      (error "Invalid syntax:~%Only one of :print-function or :print-object is allowed but~S"options))
    (or (and print-function
	     `((DEFMETHOD PRINT-OBJECT((OBJ ,name)STREAM)
			  (,print-function OBJ STREAM *PRINT-LEVEL*))))
	(and print-object
	     `((DEFMETHOD PRINT-OBJECT((OBJ ,name)STREAM)
			  (,print-object OBJ STREAM)))))))

(defun copier(name options)
  (flet((DEF-FORM(method)
	  `(,@(may-generic method)
	    (DEFMETHOD,method((ARG ,name))
	      (LET((OBJ(MAKE-INSTANCE(CLASS-OF ARG))))
		(DOLIST(SLOT(SLOTS<=OBJ ARG))
		  (IF(SLOT-BOUNDP ARG SLOT)
		    (SETF(SLOT-VALUE OBJ SLOT)(SLOT-VALUE ARG SLOT))
		    (SLOT-MAKUNBOUND OBJ SLOT)))
		OBJ))))
	)
    (let((option(assoc :copier options)))
      (if option
	(when(cadr option)
	  (DEF-FORM(cadr option)))
	(DEF-FORM(method-name "COPY-" name))))))

#@(:closer-mop #:slot-definition-name #:class-slots)
(defun slots<=obj(obj)
  (mapcar #'slot-definition-name (class-slots(class-of obj))))

(defun may-generic(method)
  (when (or (null(fboundp method))
	    (not(typep (fdefinition method) 'generic-function)))
    `((DEFGENERIC,method(ARG)))))

(defun predicate(name options)
  (flet((DEF-FORM(method)
	  #.(or #+(or clisp sbcl)
		'`((DEFUN,method(ARG)
		     (TYPEP ARG ',name)))
		'`(,@(may-generic method)
		    (DEFMETHOD,method((ARG ,name))ARG)
		    (DEFMETHOD,method(ARG)(DECLARE(IGNORE ARG))NIL))))
	)
    (let((option(assoc :predicate options)))
      (if option
	(when(cadr option)
	  (DEF-FORM(cadr option)))
	(DEF-FORM(method-name (conc-name nil name)
			      "P"))))))

#@(:closer-mop #:class-slots #:slot-definition-name #:class-finalized-p #:finalize-inheritance)

(defun accessors(name options)
  (let((includes(collect-option :include options))
       (conc-name(conc-name options name)))
    (when includes
      (uiop:while-collecting(acc)
	(labels((ENSURE-CLASS-SLOTS(class)
		  (ENSURE-FINALIZE class)
		  (class-slots class))
		(ENSURE-FINALIZE(class)
		  (unless(class-finalized-p class)
		    (finalize-inheritance class)))
		(GENERIC?(generic)
		  (when generic
		    (acc (car generic))))
		(COLLECT(include slot-name)
		  (unless(find slot-name (cddr include) :key #'car)
		    (let((method-name(method-name conc-name slot-name))
			 (super-accessor(method-name (conc-name options (cadr include))
						     slot-name)))
		      (GENERIC?(may-generic method-name))
		      (acc `(DEFMETHOD,method-name((#0=#:ARG ,name))
			      (,super-accessor #0#)))
		      (unless(cadr(member :read-only include))
			(GENERIC?(may-generic`(SETF ,method-name)))
			(acc `(DEFMETHOD(SETF,method-name)(#1=#:NEW(#0# ,name))
				(SETF(,super-accessor #0#)#1#)))))))
		)
	  (dolist(include includes)
	    (dolist(slot(ENSURE-CLASS-SLOTS(find-class(cadr include))))
	      (COLLECT include(slot-definition-name slot)))))))))
