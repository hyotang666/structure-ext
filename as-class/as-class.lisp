(defpackage :structure-ext.as-class(:use :cl)
  (:import-from :resignal-bind #:Resignal-bind)
  (:nicknames "AS-CLASS")
  (:export
    #:defstruct*
    ))
(in-package :structure-ext.as-class)

(defmacro defstruct* (&body body)
  (multiple-value-bind(name options documentation slots)(parse body)
    (check options)
    `(PROGN
       (DEFCLASS,name,(super-classes options)
         ,(slots slots options name)
         ,@(may-initargs options)
         ,@(may-documentation documentation))
       ,@(constructors name options)
       ,@(print-function name options)
       ,@(copier name options)
       ,@(predicate name options)
       ,@(accessors name options)
       ',name)))

(defun parse(body)
  (labels((NAME&OPTIONS(name&options)
            (if(symbolp name&options)
              (values name&options nil)
              (values (car name&options) (CANONICALIZE(cdr name&options)))))
          (SLOTS(slots)
            (if(stringp(car slots))
              (values (car slots)(CANONICALIZE(cdr slots)))
              (values nil (CANONICALIZE slots))))
          (CANONICALIZE(slots)
            (mapcar #'uiop:ensure-list slots))
          )
    (multiple-value-call #'values (NAME&OPTIONS(car body))(SLOTS(cdr body)))))

(defun check(options)
  (flet((check(type)
          (when(assoc type options)
            (error "Options ~S is invalid in DEFSTRUCT* form.~%~S"type options))))
    (mapc #'check `(:type :named :initial-offset))))

(defun super-classes(options)
  (mapcar #'second (collect-option :include options)))

(defun collect-option(option options)
  (remove-if (complement(lambda(x)(eq option x)))
             options :key #'car))

(defun slots(slots options class-name)
  (let((conc-name(conc-name options class-name)))
    (loop :for slot :in slots
          :collect (enslot slot conc-name))))

(defun conc-name(options class-name)
  (let((conc-name(assoc :conc-name options)))
    (if conc-name
      (cadr conc-name)
      (format nil "~A-"class-name))))

(macrolet((!(form)
            `(RESIGNAL-BIND((ERROR()'SIMPLE-ERROR
                              :FORMAT-CONTROL "Missng initform.~%~S"
                              :FORMAT-ARGUMENTS(LIST SLOT)))
               ,form)))

  (defun enslot(slot conc-name) ; separated cause of huge.
    (labels((MAY-TYPE-SPEC(slot-options)
              (let((spec(!(getf slot-options :type))))
                (when spec
                  `(:TYPE ,spec))))
            (INITFORM(init-form)
              `(:initform ,init-form))
            (INITARG(slot-name)
              (intern(symbol-name slot-name) :keyword))
            (MAY-ACCESSORS(conc-name slot-name slot-options)
              `(,(if(!(getf slot-options :read-only))
                   :reader
                   :accessor)
                 ,(METHOD-NAME conc-name slot-name)))
            )
      (destructuring-bind(slot-name &optional init-form . slot-options)slot
        `(,slot-name
           ,@(MAY-TYPE-SPEC slot-options)
           ,@(INITFORM init-form)
           :INITARG ,(INITARG slot-name)
           ,@(MAY-ACCESSORS conc-name slot-name slot-options))))))

(defun method-name(conc-name slot-name)
  (intern(format nil "~@[~A~]~A" conc-name slot-name)))

(defun may-documentation(doc)
  (when doc
    `((:DOCUMENTATION ,doc))))

(defun may-initargs(options)
  (labels((DEFAULT-INITARGS(super-classes)
            (loop :for option :in super-classes
                  :when (third option)
                  :nconc (OPTION-PLIST (cddr option))))
          (OPTION-PLIST(slot-descriptions)
            (loop :for slot-description :in slot-descriptions
                  :when (symbolp slot-description)
                  :collect (intern(symbol-name slot-description):keyword)
                  :and :collect NIL
                  :else :collect (intern (symbol-name(car slot-description))
                                         :keyword)
                  :and :collect (cadr slot-description))))
    (let((superclasses(collect-option :include options)))
      (when superclasses
        (let((initargs(DEFAULT-INITARGS superclasses)))
          (when initargs
            `((:DEFAULT-INITARGS ,@initargs))))))))

(defun constructors(name options)
  (labels((DEFAULT-CONSTRUCTOR(constructor)
            `(DEFUN,constructor(&REST ARGS)
               (APPLY #'MAKE-INSTANCE ',name ARGS)))
          (DEFAULT-NAME(name)
            (intern(format nil "MAKE-~A"name)))
          (REC(constructors &optional acc)
            (if(endp constructors)
              (DO-RETURN acc)
              (BODY(car constructors)(cdr constructors)acc)))
          (BODY(constructor rest acc)
            (etypecase constructor
              ((CONS (EQL :CONSTRUCTOR) NULL)
               (REC rest (push (DEFAULT-CONSTRUCTOR(DEFAULT-NAME name))
                               acc)))
              ((CONS (EQL :CONSTRUCTOR) (CONS SYMBOL NULL))
               (if(second constructor)
                 (REC rest (push (DEFAULT-CONSTRUCTOR(second constructor))
                                 acc))
                 (DO-RETURN acc)))
              ((CONS (EQL :CONSTRUCTOR) (CONS SYMBOL (CONS T NULL)))
               (REC rest
                    (push `(DEFUN,(second constructor),(third constructor)
                             (MAKE-INSTANCE ',name ,@(CANONICALIZE (third constructor))))
                          acc)))))
          (CANONICALIZE(lambda-list)
            (loop :for var :in (lambda-fiddle:extract-all-lambda-vars lambda-list)
                  :collect (intern(symbol-name var):keyword)
                  :collect var))
          (DO-RETURN(acc)
            (nreverse acc))
          )
    (let((constructors(collect-option :constructor options)))
      (if(null constructors)
        `(,(DEFAULT-CONSTRUCTOR(DEFAULT-NAME name)))
        (REC constructors)))))

(defun print-function(name options)
  (let((print-function(cadr(assoc :print-function options)))
       (print-object(cadr(assoc :print-object options))))
    (when(and print-function print-object)
      (error "Invalid syntax:~%Only one of :print-function or :print-object is allowed but~S"options))
    (or (and print-function
             `((DEFMETHOD PRINT-OBJECT((OBJ ,name)STREAM)
                          (,print-function OBJ STREAM *PRINT-LEVEL*))))
        (and print-object
             `((DEFMETHOD PRINT-OBJECT((OBJ ,name)STREAM)
                          (,print-object OBJ STREAM)))))))

(defun copier(name options)
  (flet((DEF-FORM(method)
          `(,@(may-generic method)
            (DEFMETHOD,method((ARG ,name))
              (LET((OBJ(MAKE-INSTANCE(CLASS-OF ARG))))
                (DOLIST(SLOT(SLOTS<=OBJ ARG))
                  (IF(SLOT-BOUNDP ARG SLOT)
                    (SETF(SLOT-VALUE OBJ SLOT)(SLOT-VALUE ARG SLOT))
                    (SLOT-MAKUNBOUND OBJ SLOT)))
                OBJ))))
        )
    (let((option(assoc :copier options)))
      (if option
        (when(cadr option)
          (DEF-FORM(cadr option)))
        (DEF-FORM(method-name "COPY-" name))))))

(defun slots<=obj(obj)
  (mapcar #'c2mop:slot-definition-name (c2mop:class-slots(class-of obj))))

(defun may-generic(method &optional(lambda-list '(arg)))
  (when (or (null(fboundp method))
            (not(typep (fdefinition method) 'generic-function)))
    `((DEFGENERIC,method,lambda-list))))

(defun predicate(name options)
  (flet((DEF-FORM(method)
          #.(or #+(or clisp sbcl)
                '`((DEFUN,method(ARG)
                     (TYPEP ARG ',name)))
                '`(,@(may-generic method)
                    (DEFMETHOD,method((ARG ,name))ARG)
                    (DEFMETHOD,method(ARG)(DECLARE(IGNORE ARG))NIL))))
        )
    (let((option(assoc :predicate options)))
      (if option
        (when(cadr option)
          (DEF-FORM(cadr option)))
        (DEF-FORM(method-name (conc-name nil name)
                              "P"))))))

(defun accessors(name options)
  (let((includes(collect-option :include options)))
    (when includes
      (uiop:while-collecting(ACC)
        (labels((ENSURE-CLASS-SLOTS(class)
                  (ENSURE-FINALIZE class)
                  (c2mop:class-slots class))
                (ENSURE-FINALIZE(class)
                  (unless(c2mop:class-finalized-p class)
                    (c2mop:finalize-inheritance class)))
                (GENERIC?(generic)
                  (when generic
                    (ACC (car generic))))
                (COLLECT(include slot-name)
                  (let((method-name(method-name (conc-name options name)
                                                slot-name))
                       (super-accessor(method-name (conc-name options (cadr include))
                                                   slot-name)))
                    (GENERIC?(may-generic method-name))
                    (ACC `(DEFMETHOD,method-name((#0=#:ARG ,name))
                            (,super-accessor #0#)))
                    (when(and (HAS-SETTER? super-accessor)
                              (null(cadr(member :read-only include))))
                      (GENERIC?(may-generic`(SETF ,method-name)'(new arg)))
                      (ACC `(DEFMETHOD(SETF,method-name)(#1=#:NEW(#0# ,name))
                              (SETF(,super-accessor #0#)#1#))))))
                (HAS-SETTER?(super-accessor)
                  (values(ignore-errors(fdefinition `(setf ,super-accessor)))))
                )
          (dolist(include includes)
            (dolist(slot(ENSURE-CLASS-SLOTS(find-class(cadr include))))
              (COLLECT include(c2mop:slot-definition-name slot)))))))))
